/**
 * @summary Supplemental service-worker file. Appends functionality to
 *          the service-worker generated by the VitePWA "generateSW"
 *          strategy.
 * 
 * @author  Tyler Maloney
 */

/**
 * @summary Handles splitting of workbox precache into "mapTiles" cache consisting of
 *          map tiles, and the "site" cache which contains everything else from precache.
 *
 *          Deletes the original file from precache after it has been moved to ensure
 *          cache size remains below 50mb limit (iOS Safari limitation).
 *          After the files have been moved to the separate caches, the empty precache
 *          is deleted.
 *          
 * @param  'activate' is the event which this listener will listen for.
 *         This event fires as soon as the service-worker is finished precaching assets
 *         and is functional.
 * @type   {event}
 * @author Tyler Maloney
 */
self.addEventListener('activate', (event) => {
    event.waitUntil(
      self.clients.claim().then(() => {
        console.log('Service worker has taken control of clients');
        // Move specific assets from the precache to the "mapTiles" cache
        return caches.open('mapTiles').then((mapTilesCache) => {
          return caches.open('site').then((siteCache) => {
            return caches.keys().then((cacheNames) => {
              const precacheNames = cacheNames.filter((cacheName) => cacheName.startsWith('workbox-precache-v2'));
              return Promise.all(
                precacheNames.map((precacheName) => {
                  return caches.open(precacheName).then((precache) => {
                    return precache.keys().then((cacheKeys) => {
                      const mapTilesUrls = cacheKeys.filter((cacheKey) => cacheKey.url.includes('mapTiles'));
                      const siteUrls = cacheKeys.filter((cacheKey) => !cacheKey.url.includes('mapTiles'));
  
                      // Move assets matching "mapTiles" to "mapTiles" cache
                      const mapTilesPromises = mapTilesUrls.map((url) => {
                        return precache.match(url).then((response) => {
                          if (response) {
                            return mapTilesCache.put(url, response.clone()).then(() => {
                              // Delete the original asset from the precache
                              return precache.delete(url);
                            });
                          }
                        });
                      });
  
                      // Move assets not matching "mapTiles" to "site" cache
                      const sitePromises = siteUrls.map((url) => {
                        return precache.match(url).then((response) => {
                          if (response) {
                            return siteCache.put(url, response.clone()).then(() => {
                              // Delete the original asset from the precache
                              return precache.delete(url);
                            });
                          }
                        });
                      });
  
                      return Promise.all([...mapTilesPromises, ...sitePromises]);
                    });
                  });
                })
              );
            });
          });
        }).then(() => {
          return caches.keys().then((cacheNames) => {
            const precacheNamesToDelete = cacheNames.filter((cacheName) => cacheName.startsWith('workbox-precache-v2'));
            return Promise.all(
              precacheNamesToDelete.map((cacheName) => {
                return caches.delete(cacheName);
              })
            );
          });
        }).then(() => {
        }).catch((error) => {
          console.error('Error deleting caches:', error);
        });
      })
    );
  });
  
/**
 * @summary Deletes the "mapTiles" cache, through an event linked to the
 *          "Delete Data" button in the "Delete Mapping Data"
 *          accordion tab.
 *          
 * @param  'message' is the event which this listener will listen for.
 *         The message event is used in a page controlled by a 
 *         service worker to receive messages from the service worker.
 * @type  {event}
 * @author Tyler Maloney
 */
self.addEventListener('message', (event) => {
  if (event.data && event.data.action === 'clearCache') {
    caches.keys().then((cacheNames) => {
      const cachesToDelete = cacheNames.filter((cacheName) => cacheName === 'mapTiles');
      return Promise.all(cachesToDelete.map((cacheName) => caches.delete(cacheName)));
    }).then(() => {
      event.source.postMessage({ action: 'clearCache', success: true });
    }).catch((error) => {
      console.error('Cache clear error:', error);
      event.source.postMessage({ action: 'clearCache', error });
    });
  }
});
